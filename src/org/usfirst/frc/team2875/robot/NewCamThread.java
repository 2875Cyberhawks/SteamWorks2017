package org.usfirst.frc.team2875.robot;

import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

import org.opencv.core.*;
import org.opencv.imgproc.*;

import edu.wpi.cscore.CvSource;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.cscore.VideoMode.PixelFormat;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
* VisionCode class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class NewCamThread {

	//Outputs
	private Mat blurOutput = Mat.zeros(new Size(HEIGHT, WIDTH), CvType.CV_8UC3);
	private Mat hslThresholdOutput =  Mat.zeros(new Size(HEIGHT, WIDTH), CvType.CV_8UC3);
	private Mat cvCannyOutput = Mat.zeros(new Size(HEIGHT, WIDTH), CvType.CV_8UC3);
	
	
	private double dhslHueLower =45.32374100719424;
	private double dhslLuminanceLower = 126.12410071942446;
	private double dhslSaturationLower = 96.31294964028775;
	private double dhslHueUpper =180.0;
	private double dhslLuminanceUpper = 255.0;
	private double dhslSaturationUpper = 227.09595959595958;
	
	private double hslHueLower =45.32374100719424;
	private double hslLuminanceLower = 126.12410071942446;
	private double hslSaturationLower = 96.31294964028775;
	private double hslHueUpper =180.0;
	private double hslLuminanceUpper = 227.09595959595958;
	private double hslSaturationUpper = 255.0;
	private double bradius = 8.1;
	
	UsbCamera camera;
	CvSource outputStream;
	UsbCamera camera2;
	Mat hierarchy;
	public boolean running = true;
	public int targetLocation = 0;
	public boolean hasTarget = false;
	static final int WIDTH = 160;
	static final int HEIGHT = 120;
	static final double[] white = new double[] {1,1,1};
	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	public NewCamThread() {
		SmartDashboard.putBoolean("Camera Threshold Mode", false);
		hierarchy = new Mat();
		System.out.println("SETTING UP CAMERAS");
		//SmartDashboard.putNumber("Peg Cam Threshold", 145);
    	//SmartDashboard.putNumber("Peg Cam Threshold Upper", 240);
    	camera = CameraServer.getInstance().startAutomaticCapture();
    	camera.setResolution(WIDTH, HEIGHT);
	    //camera.setExposureManual(-1);
	    camera.setBrightness(1);
	    camera.setFPS(15);
	    camera.setPixelFormat(PixelFormat.kMJPEG);
		outputStream = CameraServer.getInstance().putVideo("Processed", 320, 240);
		camera2 = CameraServer.getInstance().startAutomaticCapture(1);
    	camera2.setFPS(10);
    	camera2.setResolution(400, 300);
    	camera2.setPixelFormat(PixelFormat.kMJPEG);
		System.out.println("Camera Init");
		run();
	}
	
	private void run() {
		Thread thread =  new Thread(()->{
			while(!Thread.interrupted()){
				if(!running){
					outputStream.free();
					CameraServer.getInstance().removeCamera("USB Camera 0");
					
					break;
				}
				Mat input =  Mat.zeros(new Size(WIDTH, HEIGHT), CvType.CV_8UC3);
			//	System.out.println("Processing");
				if(CameraServer.getInstance().getVideo() != null) {
					try {
						CameraServer.getInstance().getVideo().grabFrame(input);
							process(input);
					}catch(Exception e) {
						System.out.println("Something failed while grabbing a frame from source. ");
						e.printStackTrace();
					}
					
				}
				
			}
	    });
		thread.start();
	}
	
	
	public void stop() {
		running = false;
	}
	
	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(Mat source0) {
		if(source0 == null) {
			System.out.println("INPUT MAT IS NULL");
			return;
		}
		List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
		Mat hierarchy = Mat.zeros(source0.size(), CvType.CV_8UC3);
		//System.out.println("We made it to process");
		
		hslHueLower = Robot.prefs.getDouble("Hue Threshold Lower", dhslHueLower);
		hslLuminanceLower = Robot.prefs.getDouble("Luminance Threshold Lower", dhslLuminanceLower);
		hslSaturationLower = Robot.prefs.getDouble("Saturation Threshold Lower",dhslSaturationLower);
		hslHueUpper = Robot.prefs.getDouble("Hue Threshold Upper", dhslHueUpper);
		hslLuminanceUpper = Robot.prefs.getDouble("Luminance Threshold Upper", dhslLuminanceUpper);
		hslSaturationUpper = Robot.prefs.getDouble("Saturation Threshold Upper",dhslSaturationUpper);
		bradius = Robot.prefs.getDouble("Blur Radius",8);
		// Step Blur0:
		Mat blurInput = source0;
		BlurType blurType = BlurType.get("Box Blur");
		double blurRadius = bradius;
		blur(blurInput, blurType, blurRadius, blurOutput);

		// Step HSL_Threshold0:
		Mat hslThresholdInput = blurOutput;
		Mat yeet = blurOutput;
		Imgproc.cvtColor(blurOutput, yeet, Imgproc.COLOR_BGR2HLS);
		//System.out.println(yeet.size());
		//double[] hsl = yeet.get(120, 160);
		//System.out.println(hsl[0] + " "+  hsl[1] + " " + hsl[2]);
		double[] hslThresholdHue = {hslHueLower, hslHueUpper};
		double[] hslThresholdSaturation = {hslSaturationLower, hslSaturationUpper};
		double[] hslThresholdLuminance = {hslLuminanceLower, hslLuminanceUpper};
		hslThreshold(hslThresholdInput, hslThresholdHue, hslThresholdSaturation, hslThresholdLuminance, hslThresholdOutput);
		if(SmartDashboard.getBoolean("Camera Threshold Mode", false)) {
			//outputStream.putFrame(hslThresholdOutput);
			return;
		}

		// Step CV_Canny0:
		Mat cvCannyImage = hslThresholdOutput;
		double cvCannyThreshold1 = 0.0;
		double cvCannyThreshold2 = 0.0;
		double cvCannyAperturesize = 3;
		boolean cvCannyL2gradient = false;
		cvCanny(cvCannyImage, cvCannyThreshold1, cvCannyThreshold2, cvCannyAperturesize, cvCannyL2gradient, cvCannyOutput);
        //outputStream.putFrame(cvCannyOutput);
        
	   // System.out.println(cvCannyOutput.size());
		ArrayList<Integer> indexes = new ArrayList<Integer>();
		Imgproc.findContours(cvCannyOutput, contours, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
		Rect[] rects = new Rect[contours.size()];
		List<MatOfPoint> polys = new ArrayList<MatOfPoint>();
		Mat output = new Mat(source0.size(), CvType.CV_8UC3);
		for(int i = 0;i < contours.size();i++) {
			//MatOfPoint2f moment = new MatOfPoint2f(contours.get(i).toArray());
			//Imgproc.approxPolyDP(moment, contours_poly[i], (double)3.0, true);
			//Imgproc.findContours(image, contours, hierarchy, mode, method);
			Imgproc.drawContours(output, contours, i, new Scalar(0,255,0));
			rects[i] = Imgproc.boundingRect(new MatOfPoint(contours.get(i)));
		//	Imgproc.rectangle(output, rects[i].tl(), rects[i].br(), new Scalar(0,0,255));
		}
		double goalRatio = Robot.prefs.getDouble("Closest Ratio", 2.5);
		ArrayList<Rect> orderByRatio = new ArrayList<Rect>();
		Rect[] largestRects = new Rect[2];
		double largest = 0;
		double largest2 = 0;
		for(int i = 0;i < contours.size();i++) {
			if(rects[i].height > rects[i].width && rects[i].area() > largest2) {
				if(rects[i].area() > largest) {
					largestRects[1] = largestRects[0];
					largest2 = largest;
					largest = rects[i].area();
					largestRects[0] = rects[i];
				}else {
					largestRects[1] = rects[i];
					largest2 = rects[i].area();
				}
			}
		}
		/*double ratio = 50000;
		for(int j = 0;j < contours.size();j++) {
		for(int i = 0;i < contours.size();i++) {
			int ind = -1;
			
			if(!orderByRatio.contains(rects[i]) && rects[i].height > rects[i].width &&  (Math.abs((double)rects[i].height / (double)rects[i].width) - goalRatio) < ratio) {
				ratio = (Math.abs((double)rects[i].height / (double)rects[i].width) - goalRatio);
				ind  = i;
				System.out.println("masd");
			}
			if(ind == -1) {
				break;
			}
			orderByRatio.add(rects[ind]);
		}
		}
		for(int i = 0;i < orderByRatio.size();i++) {
			Imgproc.rectangle(output, orderByRatio.get(i).tl(), orderByRatio.get(i).br(), new Scalar(0,255,0));
		}
		double size = 0;
		int avoid = -1;
		for(int i = 0;i < orderByRatio.size();i++) {
		//	Imgproc.rectangle(output, rects[i].tl(), rects[i].br(), new Scalar(255,255,255));
			if(orderByRatio.get(i).height > orderByRatio.get(i).width && orderByRatio.get(i).area() > size) {
				size = orderByRatio.get(i).area();
				avoid = i;
			}
		}
		if(avoid != -1) {
		largestRects[0] = orderByRatio.get(avoid);
		
		for(int i = 0;i < orderByRatio.size();i++) {
			if(i != avoid && (Math.abs(getCenter(orderByRatio.get(i)).y - getCenter(largestRects[0]).y) < 15)) {
				largestRects[1] = rects[i];
			}
		}
		}
		//ArrayList<Integer> avoid = new ArrayList<Integer>();
		//for(int i = 0;i < contours.size();i++) {
		//	for(int j = 0;j< contours.size();j++) {
		//		if(rects[i].area() > rects[j].area() && rects[i].contains(getCenter(rects[j])) && i != j){
				//	avoid.add(j);
		//		}
		//	}
	//	}
		//for(int i = 0;i< contours.size();i++) {
		//	if(!avoid.contains(i)) {
				//Imgproc.rectangle(output, rects[i].tl(), rects[i].br(), new Scalar(0,0,255));
		//	}
		//}
	//	outputStream.putFrame(output);
	
	
		/*double ratio = 500;
		double ratio2 = 500;
		for(int i = 0;i < contours.size();i++) {
			if(Math.abs(((double)rects[i].height / (double)rects[i].width) - goalRatio) < ratio2 && rects[i].height > rects[i].width)  {
				if((Math.abs(((double)rects[i].height / (double)rects[i].width) - goalRatio) < ratio)) {
					ratio2 = ratio;
					largestRects[1] = largestRects[0];
					ratio = (Math.abs(((double)rects[i].height / (double)rects[i].width) - goalRatio));
					largestRects[0] = rects[i];
					
				}else {
					ratio2 = (Math.abs(((double)rects[i].height / (double)rects[i].width) - goalRatio));
					largestRects[1] = rects[i];
					
				}
			}
		}*/
		
		if(largestRects[0] != null) {
			Imgproc.rectangle(output, largestRects[0].tl(), largestRects[0].br(), new Scalar(0,0,255));
		}

		Point avg;
		if(largestRects[1] != null && largestRects[0] != null && Math.abs(getCenter(largestRects[0]).y - getCenter(largestRects[1]).y) < 5
				&& !largestRects[0].contains(getCenter(largestRects[1]))
				&& !largestRects[1].contains(getCenter(largestRects[0]))) {
			System.out.println((double)largestRects[1].height / (double)largestRects[1].width);
			Imgproc.rectangle(output, largestRects[0].tl(), largestRects[0].br(), new Scalar(0,0,255));
			Imgproc.rectangle(output, largestRects[1].tl(), largestRects[1].br(), new Scalar(0,0,255));
			Point avg1 = new Point((largestRects[0].tl().x + largestRects[0].br().x) / 2,(largestRects[0].tl().y + largestRects[0].br().y) / 2);
			Point avg2 = new Point((largestRects[1].tl().x + largestRects[1].br().x) / 2,(largestRects[1].tl().y + largestRects[1].br().y) / 2);
			avg = new Point((avg1.x + avg2.x) / 2,(avg1.y + avg2.y) / 2);
			Imgproc.line(output, new Point(avg.x,0), new Point(avg.x,HEIGHT), new Scalar(255,0,0));
			Imgproc.line(output, new Point(0,avg.y), new Point(WIDTH,avg.y), new Scalar(255,0,0));
			targetLocation = (int)(avg.x - (160));
			hasTarget = true;
			if(avg.y > (HEIGHT * 0.6)) {
			//	hasTarget = false;
			}
		}else {
			hasTarget =false;
		}
		
		SmartDashboard.putBoolean("Has Target", hasTarget);
		outputStream.putFrame(output);
		output.release();
		for(int i =0;i < contours.size();i++) {
			contours.get(i).release();
		}
		
	}
	private Point getCenter(Rect rect) {
		int x = (int)(rect.tl().x + rect.br().x)/2;
		int y = (int)(rect.tl().y + rect.br().y)/2;
		return new Point(x,y);
	}
	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blurOutput() {
		return blurOutput;
	}

	/**
	 * This method is a generated getter for the output of a HSL_Threshold.
	 * @return Mat output from HSL_Threshold.
	 */
	public Mat hslThresholdOutput() {
		return hslThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_Canny.
	 * @return Mat output from CV_Canny.
	 */
	public Mat cvCannyOutput() {
		return cvCannyOutput;
	}


	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
		BILATERAL("Bilateral Filter");
		private final String label;
		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
				return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = (int)(doubleRadius + 0.5);
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}

	/**
	 * Segment an image based on hue, saturation, and luminance ranges.
	 *
	 * @param input The image on which to perform the HSL threshold.
	 * @param hue The min and max hue
	 * @param sat The min and max saturation
	 * @param lum The min and max luminance
	 * @param output The image in which to store the output.
	 */
	private void hslThreshold(Mat input, double[] hue, double[] sat, double[] lum,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HLS);
		Core.inRange(out, new Scalar(hue[0], lum[0], sat[0]),
			new Scalar(hue[1], lum[1], sat[1]), out);
	}

	/**
	 * Applies a canny edge detection to the image.
	 * @param image image to use.
	 * @param thres1 first threshold for the canny algorithm.
	 * @param thres2 second threshold for the canny algorithm.
	 * @param apertureSize aperture size for the canny operation.
	 * @param gradient if the L2 norm should be used.
	 * @param edges output of the canny.
	 */
	private void cvCanny(Mat image, double thres1, double thres2,
		double apertureSize, boolean gradient, Mat edges) {
		Imgproc.Canny(image, edges, thres1, thres2, (int)apertureSize, gradient);
	}



}

